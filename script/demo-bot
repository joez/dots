#!/usr/bin/env bash
# author: joe.zheng
# version: 23.06.22

DEMO_SPEED="${DEMO_SPEED:-15}"   # approximate chars per second
DEMO_PS="${DEMO_PS:-\u@\h:\W$ }" # PS1 for demo
DEMO_WAIT="on"                   # wait on each command

# show message only
function msg {
  :
}

# simulate user input
DEMO_INPUT_DELAY="0.1"
function demo_input {
  local s="$*"
  for ((i=0; i<${#s}; i++)); do
    local c="${s:$i:1}"
    echo -n "$c"
    sleep $DEMO_INPUT_DELAY
    if [[ $c == ' ' || $c == ',' || $c == '.' ]]; then
      sleep $DEMO_INPUT_DELAY 
    elif [[ $((RANDOM % 3 )) == 1 ]]; then
      sleep $DEMO_INPUT_DELAY 
    fi
  done
}

function demo_prompt {
  local p=$(PS1="$DEMO_PS" $BASH --norc -i </dev/null 2>&1)
  echo -n "${p%exit}"
}

# hook every command
function demo_hook {
  [[ $DEMO_MODE == 'off' ]] && return

  local cmd=${BASH_COMMAND%% *}
  if [[ $cmd == demo_* ]]; then
    return # skip demo_* commands
  elif [[ $cmd == "msg" ]]; then
    local arg=$(eval echo "${BASH_COMMAND#* }") # unquote the string
    demo_prompt && demo_input "# $arg"
  else
    demo_prompt && demo_input "$BASH_COMMAND"
  fi
  if [[ $DEMO_WAIT == 'on' ]]; then
    read
  else
    echo
  fi
}

function demo_ctl {
  local opt="$1"
  if [[ $opt == 'init' ]]; then
    DEMO_MODE='on'
    DEMO_INPUT_DELAY="$(bc <<< "scale=2; 1/$DEMO_SPEED")"
    trap demo_hook DEBUG
  elif [[ $opt == 'on' ]]; then
    DEMO_MODE='on'
  elif [[ $opt == 'off' ]]; then
    DEMO_MODE='off'
  elif [[ $opt == 'wait' ]]; then
    if [[ $2 == 'off' ]]; then
      DEMO_WAIT='off'
    else
      DEMO_WAIT='on'
    fi
  else
    echo "no such option: $opt"
    exit 1
  fi
}

function demo_init {
  demo_ctl init
}

function demo_self {
  local self="$(basename ${BASH_SOURCE[0]})"
  cat <<EOF
# $self enables you to script your demo without typing as you present.

# Using $self is incredibly easy!
# Add the following lines to your demo (bash) script:

PATH=\$(dirname \$0):\$PATH
source $(basename ${BASH_SOURCE[0]})

# You can configure it using environment variables, e.g.:

DEMO_SPEED=$DEMO_SPEED
DEMO_PS='$DEMO_PS'

# Start the demo mode with the command:

demo_init

# You can display information to users using the 'msg' function
# and adjust demo options using the 'demo_ctl' function.
# Here are some examples, check the source code for more details.

msg "Display a message to the user"  # Press ENTER to continue
demo_ctl wait off                    # Turn off waiting on each command

# The self-demo will start now. Press ENTER to continue...
EOF
  read

  # configure the demo first
  DEMO_PS="> demo\$ "
  # start the demo
  demo_init

  msg "Message to the user, press ENTER to continue"
  msg "Message with the variable \$0: $0"
  msg "Message with quotation marks: \"'"
  echo "Run the 'echo' command"
  pwd

  msg "Turn off the demo mode with 'demo_ctl off'"
  demo_ctl off
  echo "Now you can't see the message"
  msg "It's a secret, you can't see it"
  echo "The script continues to run, but you can't see the command itself"
  pwd

  echo "Enable the demo again with 'demo_ctl on'"
  demo_ctl on
  msg "You can create a subshell for interactive operation. Run 'exit' to quit"
  (exec $BASH)
  msg "You can also SSH to a remote server"
  msg "Disable waiting for confirmation on each command with 'demo_ctl wait off'"
  demo_ctl wait off
  msg "No waiting for user confirmation"
  msg "Continue to the end"
}

# if it is not sourced by other script show the self test demo
if [[ ${BASH_SOURCE[0]} == $0 ]]; then
  demo_self
fi
