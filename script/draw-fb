#!/usr/bin/env bash
# author: joe.zheng
# version: 24.10.16

set -e

SELF="$(basename $0)"
SELF_VERSION="$(sed -n '1,4s/# version: \(.*\)/\1/p' $0)"

FBDEV="/dev/fb0"  # framebuffer device
COLOR="red"       # color name or BGRA value, e.g. "\xFF\xFF\xFF\xFF"

WIDTH=1280        # framebuffer width
BPP=32            # bits per pixel, hardcoded for simplicity

DEBUG=${DEBUG:-n} # for debugging, y or n
if [[ $DEBUG == 'y' ]]; then
  STATUS_LINE=$(($(tput lines) - 2))
  function reset_cursor() {
    tput cup $STATUS_LINE 0 && tput el
  }
  function dbg() {
    reset_cursor && echo "> ${FUNCNAME[1]}: $@" >&2
  }
else
  function dbg() { :; }
fi

function main() {
  # parse command-line options
  while getopts ":c:f:h" opt; do
    case $opt in
      c) COLOR="$OPTARG" ;;
      f) FBDEV="$OPTARG" ;;
      h) usage; exit 0 ;;
      *) echo "Invalid option: -${OPTARG}" >&2; usage; exit 1 ;;
    esac
  done
  shift $((OPTIND-1))
  
  set_fbdev "$FBDEV"
  set_color "$COLOR"

  cmd="exec_cmds"
  if [[ -n "$1" ]]; then
    cmd="$1"
    shift
  fi
  case "$cmd" in
    set_pixel | draw_line | draw_rect | fill_rect | \
    self_test | exec_cmds ) $cmd "$@" ;;
    *) echo "Invalid command: $cmd" >&2; usage; exit 1 ;;
  esac
  if [[ $DEBUG == 'y' ]]; then
    reset_cursor
  fi
}

function usage() {
  cat <<EOF
Usage: $SELF [options] [cmd] [args]

  Draw simple shapes to the framebuffer.

  If no command is specified, it will wait for input from STDIN,
  type the command line by line and press CTRL + D to finish.

  Switch to a non-desktop TTY first to prevent overwritten, e.g.:

    chvt 3

Options:
  -c <color>  color to draw (default: $COLOR)
  -f <fbdev>  framebuffer device (default: $FBDEV)
  -h          show this help message

Commands:
  set_pixel <x> <y>
  draw_line <x0> <y0> <x1> <y1>
  draw_rect <x0> <y0> <x1> <y1>
  fill_rect <x0> <y0> <x1> <y1>
  exec_cmds [script]            run commands in script (default: /dev/stdin)
  self_test                     do the self-test to draw pre-defined shapes

Examples:
  1. Do the self-test

    sudo $SELF self_test

  2. Draw a line in blue

    sudo $SELF -c blue draw_line 10 10 20 20

  3. Draw multiple shapes in batch

    sudo $SELF <<EOS
    draw_line 0 0 10 10
    draw_rect 5 5 10 10
    EOS

  4. Fill a rectangle in DEBUG mode

    DEBUG=y $SELF fill_rect 0 0 10 5 2>dbg.log

Version: $SELF_VERSION
EOF

}

function exec_cmds() {
  dbg "$@"
  . "${1:-/dev/stdin}"
}

function self_test() {
  dbg "$@"
  local x=0 y=0 s=10
  local w=8 h=4 b=1

  if [[ $DEBUG == 'y' ]]; then
    s=5
  fi

  draw_rect $x $y $((x + s * w)) $((y + s * h))
  for i in $(seq $w); do
    draw_line $x $y $((x + s * i)) $((y + s * h))
    draw_line $((x + s * w)) $y $((x + s * (i - 1))) $((y + s * h))
  done
  y=$((y + s * (h + b))) w=2
  for c in r g b w; do
    set_color $c
    fill_rect $x $y $((x + s * w)) $((y + s * h))
    x=$((x + s * (w + b)))
  done
}

function set_fbdev() {
  dbg "$@"
  local fbdev="$1"
  local fbinfo="/sys/class/graphics/${fbdev##*/}"
  local fbsize="$fbinfo/virtual_size"
  local fbbpp="$fbinfo/bits_per_pixel"
  if [[ -e "$fbsize" ]]; then
    WIDTH="$(cut -d, -f1 $fbsize)"
  fi
  if [[ -e "$fbbpp" ]]; then
    local bpp="$(< $fbbpp)"
    if [[ "$bpp" != "$BPP" ]]; then
      echo "WARNING: bits per pixel $bpp is not supported"
    fi
  fi
  FBDEV="$fbdev"
}

function set_color() {
  dbg "$@"
  local color="$1"
  # convert known color name to value
  case "$color" in
    b|blue)  color="\xFF\x00\x00\xFF" ;;
    g|green) color="\x00\xFF\x00\xFF" ;;
    r|red)   color="\x00\x00\xFF\xFF" ;;
    w|white) color="\xFF\xFF\xFF\xFF" ;;
  esac
  COLOR="$color"
}

function set_pixel() {
  #dbg "$@"
  local x=$1
  local y=$2

  if [[ $DEBUG == 'y' ]]; then
    tput cup $y $x && printf "+"
  else
    local offset=$((y * WIDTH + x))
    printf "$COLOR" | dd bs=$((BPP / 8)) seek=$offset of=$FBDEV &>/dev/null
  fi
}

function draw_line() {
  dbg "$@"
  local x0=$1
  local y0=$2
  local x1=$3
  local y1=$4

  # Bresenham's algorithm
  local dx=$((x0 < x1 ? x1 - x0 : x0 - x1)) #  abs
  local dy=$((y0 < y1 ? y0 - y1 : y1 - y0)) # -abs
  local ix=$((x0 < x1 ? 1 : -1))
  local iy=$((y0 < y1 ? 1 : -1))
  local er=$((dx + dy))

  while true; do
    set_pixel $x0 $y0
    if ((er * 2 >= dy)); then
      if ((x0 == x1)); then
        break
      fi
      er=$((er + dy))
      x0=$((x0 + ix))
    fi
    if ((er * 2 <= dx)); then
      if ((y0 == y1)); then
        break
      fi
      er=$((er + dx))
      y0=$((y0 + iy))
    fi
  done
}

function draw_rect() {
  dbg "$@"
  local x0=$1
  local y0=$2
  local x1=$3
  local y1=$4

  # the top and bottom sides
  draw_line $x0 $y0 $x1 $y0
  draw_line $x0 $y1 $x1 $y1

  # the left and right sides
  draw_line $x0 $y0 $x0 $y1
  draw_line $x1 $y0 $x1 $y1
}

function fill_rect() {
  dbg "$@"
  local x0=$1
  local y0=$2
  local x1=$3
  local y1=$4

  # draw line by line
  local iy=$((y0 < y1 ? 1 : -1))
  while true; do
    draw_line $x0 $y0 $x1 $y0
    if ((y0 == y1)); then
      break
    else
      y0=$((y0 + iy))
    fi
  done
}

main "$@"
